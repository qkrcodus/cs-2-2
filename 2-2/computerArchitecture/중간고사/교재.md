RISC-V 명령어의 길이는 32bit로 고정되어 있습니다. 
따라서 명령어에 32bit 이상의 상수나 주소를 표시할 수 없어 불편합니다. 
###### 긴 상수 처리를 위한 일반적 해법과 분기 명령어에서 사용되는 명령어 주소의 최적화 방법에 대해 알아봅시다
###### 32bit RISC-V 와  64bit RISC-V 차이는?
	32bit RISC-V 는 한 레지스터에 32bit 넣을 수 있다. 
	64bit RISC-V는 한 레지스터에 64bit까지 담을 수 있다.
	명령어 길이는 32bit로 동일하다.  
	32bit는 16진수로 0x11111111 꼴
###### 레지스터에 32bit 들어갈 수 있다면서 32bit의 상수까진 저장 가능한 거 아니야?
저장은 가능하다. 하지만
명령어 길이가 32bit 여서 단일 명령어로 32bit 전체 상수를 직접적으로 레지스터에 넣고 빼는 것은 제한된다. 
이를 해결하기 위해 
1. 상위 20 bit 를 LUI로 상위 20bit를 설정하고 하위 12bit를 0으로 초기화한다.
2. 하위 12 bit 는 ADDI로 기존 레지스터에 부호 있는 12bit 정수를 더한다. 

U-type이다.
##### 32비트 상수의 적재 예시

- 레지스터에 직접 값을 더하거나 저장할 때, 그 데이터의 크기를 레지스터의 크기에 맞춰 조정해야 한다

![[Pasted image 20241012201936.png]]
- addi 명령어는 12비트의 상수를 받아서 처리한다. -2048 ~2047까지 값을 가질 수 있다. 
- 12비트의 상수를 32비트로 부호 확장하는 과정에서 양수면 0으로 음수면 1로 상위 20비트를 채운다. 
12비트 값이 `1000 0000 0000` 이면 확장 후엔 `1111 1111 1111 1000 0000 0000 0000` 가 된다 .

==고난도 뭔소리냐?==

1000 0010 값 구할 땐 0111 1101 에서 1 더해 0111 1110 : 2+4+8+16+32+64=2(63)=126 에  -1 곱한 -126. 

addi로 더할 값이0000 0000 0000 0000 0000 1000 0000 0001 이면 이걸 부호확장해서 1111 1111 1111 1111 1111 1000 0000 0001를 더해진다.
1111 1111 1111 1111 1111 1000 0000 0001 
1111 1111 1111 1111 1111 0000 0000 0000 을 빼줘야 원하는 값이 나옴. 
-(1111 1111 1111 1111 1111 0000 0000 0000 ) = 0000 0000 0000 0000 0000 1111 1111 1111 +1 = 0000 0000 0000 0000 0001 0000 0000 0000 = 2^12
##### 명령어는 32bit , 4byte word 단위로 정렬된다. 
`jal rd, offset => 함수 호출 시 사용 offset은 imm<<2 임 
pc+ offset : 새 목적지 주소 함수 호출
반환 후 돌아올 주소 : pc+4 를 rd에 저장.


